<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="1. put1.1 put方法的定义put方法向这个map中增加指定的键值对，如果map中已经包含了这个键，就替换掉旧的值，并且返回这个值。如果map中不包含这个键，就返回null。 12345678910111213141516&#x2F;** * Associates the specified value with the specified key in this map. * If the map">
<meta property="og:type" content="article">
<meta property="og:title" content="HashMap（2）- put、get和remove方法">
<meta property="og:url" content="http://example.com/2022/07/20/HashMap%EF%BC%882%EF%BC%89-%20put%E3%80%81get%E5%92%8Cremove%E6%96%B9%E6%B3%95/index.html">
<meta property="og:site_name" content="你跺你也麻">
<meta property="og:description" content="1. put1.1 put方法的定义put方法向这个map中增加指定的键值对，如果map中已经包含了这个键，就替换掉旧的值，并且返回这个值。如果map中不包含这个键，就返回null。 12345678910111213141516&#x2F;** * Associates the specified value with the specified key in this map. * If the map">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-07-19T16:00:00.000Z">
<meta property="article:modified_time" content="2022-07-21T07:40:29.431Z">
<meta property="article:author" content="zad">
<meta property="article:tag" content="源码笔记">
<meta name="twitter:card" content="summary">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>HashMap（2）- put、get和remove方法</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/posts/">Writing</a></li>
         
          <li><a target="_blank" rel="noopener" href="http://github.com/ZhangAndong12138">Projects</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" href="/2022/07/13/%E4%BD%BF%E7%94%A8maven%E7%9A%84mirror%E9%85%8D%E7%BD%AE%E4%BB%8E%E6%9C%AC%E5%9C%B0%E8%8E%B7%E5%8F%96%E4%BE%9D%E8%B5%96/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2022/07/20/HashMap%EF%BC%882%EF%BC%89-%20put%E3%80%81get%E5%92%8Cremove%E6%96%B9%E6%B3%95/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2022/07/20/HashMap%EF%BC%882%EF%BC%89-%20put%E3%80%81get%E5%92%8Cremove%E6%96%B9%E6%B3%95/&text=HashMap（2）- put、get和remove方法"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2022/07/20/HashMap%EF%BC%882%EF%BC%89-%20put%E3%80%81get%E5%92%8Cremove%E6%96%B9%E6%B3%95/&title=HashMap（2）- put、get和remove方法"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2022/07/20/HashMap%EF%BC%882%EF%BC%89-%20put%E3%80%81get%E5%92%8Cremove%E6%96%B9%E6%B3%95/&is_video=false&description=HashMap（2）- put、get和remove方法"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=HashMap（2）- put、get和remove方法&body=Check out this article: http://example.com/2022/07/20/HashMap%EF%BC%882%EF%BC%89-%20put%E3%80%81get%E5%92%8Cremove%E6%96%B9%E6%B3%95/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2022/07/20/HashMap%EF%BC%882%EF%BC%89-%20put%E3%80%81get%E5%92%8Cremove%E6%96%B9%E6%B3%95/&title=HashMap（2）- put、get和remove方法"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2022/07/20/HashMap%EF%BC%882%EF%BC%89-%20put%E3%80%81get%E5%92%8Cremove%E6%96%B9%E6%B3%95/&title=HashMap（2）- put、get和remove方法"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2022/07/20/HashMap%EF%BC%882%EF%BC%89-%20put%E3%80%81get%E5%92%8Cremove%E6%96%B9%E6%B3%95/&title=HashMap（2）- put、get和remove方法"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2022/07/20/HashMap%EF%BC%882%EF%BC%89-%20put%E3%80%81get%E5%92%8Cremove%E6%96%B9%E6%B3%95/&title=HashMap（2）- put、get和remove方法"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2022/07/20/HashMap%EF%BC%882%EF%BC%89-%20put%E3%80%81get%E5%92%8Cremove%E6%96%B9%E6%B3%95/&name=HashMap（2）- put、get和remove方法&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-put"><span class="toc-number">1.</span> <span class="toc-text">1. put</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-put%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 put方法的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-putVal%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94put%E6%93%8D%E4%BD%9C%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 putVal方法——put操作的具体实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-hash%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E9%81%BF%E5%85%8D%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 hash方法——避免哈希碰撞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%9B%9E%E5%88%B0putVal"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 回到putVal</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-get"><span class="toc-number">2.</span> <span class="toc-text">2. get</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-get%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 get方法的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-getNode%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94get%E6%93%8D%E4%BD%9C%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 getNode方法——get操作的具体实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B0%B8%E8%BF%9C%E8%A6%81%E6%A3%80%E6%9F%A5%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 为什么永远要检查第一个节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-remove"><span class="toc-number">3.</span> <span class="toc-text">3.remove</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-remove%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 remove方法的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-removeNode%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94remove%E6%93%8D%E4%BD%9C%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 removeNode方法——remove操作的具体实现</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        HashMap（2）- put、get和remove方法
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">你跺你也麻</span>
      </span>
      
    <div class="postdate">
        <time datetime="2022-07-19T16:00:00.000Z" itemprop="datePublished">2022-07-20</time>
    </div>


      
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link-link" href="/tags/%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/" rel="tag">源码笔记</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="1-put"><a href="#1-put" class="headerlink" title="1. put"></a>1. put</h2><h3 id="1-1-put方法的定义"><a href="#1-1-put方法的定义" class="headerlink" title="1.1 put方法的定义"></a>1.1 put方法的定义</h3><p><code>put</code>方法向这个map中增加指定的键值对，如果map中已经包含了这个键，就替换掉旧的值，并且返回这个值。如果map中不包含这个键，就返回<code>null</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment"> * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment"> * value is replaced.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment"> *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-putVal方法——put操作的具体实现"><a href="#1-2-putVal方法——put操作的具体实现" class="headerlink" title="1.2 putVal方法——put操作的具体实现"></a>1.2 putVal方法——put操作的具体实现</h3><p>很明显，<code>put</code>操作的具体实现都在<code>putVal</code>这个方法里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="comment">//判断table是否为空或者长度为0</span></span><br><span class="line">        n = (tab = resize()).length; <span class="comment">//调用resize方法初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">//计算key的哈希值对应的桶数组下标</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">//如果数组此项为null,新建Node对象并赋值</span></span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//如果数组此项不为null</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p; <span class="comment">//如果要put的key和第一个节点的key哈希值相同而且两个key本身也相同，即key已存在</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">//如果节点是TreeNode类型</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//其他情况，也就是节点是链表类型</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123; <span class="comment">//p的下一个节点是null，即遍历到链表末尾</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">//创建一个节点，添加到链表里</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st（原注释）</span></span><br><span class="line">                        treeifyBin(tab, hash); <span class="comment">//如果链表长度大于等于TREEIFY_THRESHOLD - 1，转换为树</span></span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">//结束循环</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">//如果要put的key和某个节点的key哈希值相同而且两个key本身也相同，即key已存在</span></span><br><span class="line">                p = e; <span class="comment">//p赋值为p的下一个节点，继续循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key （原注释，也就是key已存在的情况）</span></span><br><span class="line">            V oldValue = e.value; <span class="comment">//定义原节点的value为旧值</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>) <span class="comment">//被put方法调用时onlyIfAbsent为false，因此肯定为true</span></span><br><span class="line">                e.value = value; <span class="comment">//将源节点的value改为新的value</span></span><br><span class="line">            afterNodeAccess(e); <span class="comment">//提供给node节点被访问后的回调方法</span></span><br><span class="line">            <span class="keyword">return</span> oldValue; <span class="comment">//返回修改之前的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount; <span class="comment">//修改HashMap结构次数的计数器加1</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold) <span class="comment">//map中键值对的数量自增</span></span><br><span class="line">        resize(); <span class="comment">//如果自增后的键值对数量大于阈值时，调用resize方法</span></span><br><span class="line">    afterNodeInsertion(evict); <span class="comment">//提供给node节点增加后的回调方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//返回null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先判断了<code>map</code>的<code>table</code>是否为<code>null</code>或者长度为0，如果是，就调用<code>resize()</code>方法进行初始化。这里的<code>table</code>是一个<code>Node</code>类型的数组，也就是<code>map</code>的桶的数组。它在第一次用到的时候初始化，在有必要的时候会重新调整大小，长度永远是2的幂。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment"> * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment"> * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment"> * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>
<p>然后判断<code>table</code>的第<code>(n - 1) &amp; hash</code>项的值是否为<code>null</code>。这里的<code>n</code>是<code>table</code>的长度，<code>n - 1</code>也就是<code>table</code>数组的最大下标，<code>&amp;(与)</code>运算表示将数值转化为二进制后，每位分别进行计算，当两个数都为1时，结果为1，否则为0。举个例子，假设此处的<code>n</code>为16（也就是<code>DEFAULT_INITIAL_CAPACITY</code>，默认的初始容量），<code>hash</code>值为37，<code>n - 1</code>转为二进制为<code>1111</code>，37转为二进制为<code>100101</code>，那么<code>1111 &amp; 100101</code>结果就是<code>0101</code>，也就是5。</p>
<p>可以看出这里的运算是为了将<code>hash</code>值转化为在<code>table</code>数组下标范围内的值，那么为什么要使用<code>&amp;(与)</code>运算而不是更常见的<code>%(取模)</code>运算呢？原因是与运算的效率要远远大于取模运算，而且因为规定了<code>table</code>的长度<code>n</code>永远是2的幂，那么<code>(n - 1) &amp; hash</code>的值和<code>hash % n</code>的值必定是相等的，这样实现是使用了效率更高的方式计算出了相同的结果。</p>
<h3 id="1-3-hash方法——避免哈希碰撞"><a href="#1-3-hash方法——避免哈希碰撞" class="headerlink" title="1.3 hash方法——避免哈希碰撞"></a>1.3 hash方法——避免哈希碰撞</h3><p>那么<code>hash</code>又是是如何计算出来的呢？来看<code>hash(Object key)</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Computes key.hashCode() and spreads (XORs) higher bits of hash</span></span><br><span class="line"><span class="comment"> * to lower.  Because the table uses power-of-two masking, sets of</span></span><br><span class="line"><span class="comment"> * hashes that vary only in bits above the current mask will</span></span><br><span class="line"><span class="comment"> * always collide. (Among known examples are sets of Float keys</span></span><br><span class="line"><span class="comment"> * holding consecutive whole numbers in small tables.)  So we</span></span><br><span class="line"><span class="comment"> * apply a transform that spreads the impact of higher bits</span></span><br><span class="line"><span class="comment"> * downward. There is a tradeoff between speed, utility, and</span></span><br><span class="line"><span class="comment"> * quality of bit-spreading. Because many common sets of hashes</span></span><br><span class="line"><span class="comment"> * are already reasonably distributed (so don&#x27;t benefit from</span></span><br><span class="line"><span class="comment"> * spreading), and because we use trees to handle large sets of</span></span><br><span class="line"><span class="comment"> * collisions in bins, we just XOR some shifted bits in the</span></span><br><span class="line"><span class="comment"> * cheapest possible way to reduce systematic lossage, as well as</span></span><br><span class="line"><span class="comment"> * to incorporate impact of the highest bits that would otherwise</span></span><br><span class="line"><span class="comment"> * never be used in index calculations because of table bounds.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先调用了<code>key</code>的<code>hashCode()</code>方法获取<code>int</code>类型的哈希值，然后将哈希值<code>&gt;&gt;&gt;(无符号右移)</code>16位，再和原哈希值做<code>^(抑或)</code>运算。因为<code>int</code>类型的哈希值是32位的，而无符号右移运算在左侧补0，相当于是对哈希值的高16位和低16位做抑或运算。这么做是由于<code>table</code>的大小永远是2的幂，如果<code>table</code>的大小足够小，就相当于哈希值只有低位参与了运算，导致发生哈希碰撞的可能性变大。举个例子，假设<code>table</code>的大小为16，有两个哈希值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 0000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line">b &#x3D; 0000 0000 0000 0001 0000 0000 0000 0001</span><br></pre></td></tr></table></figure>
<p>如果不进行高16位和低16位抑或运算，<code>(n - 1) &amp; hash</code>的结果是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1111 &amp; 0000 0000 0000 0000 0000 0000 0000 0001 &#x3D; 0001</span><br><span class="line">1111 &amp; 0000 0000 0000 0001 0000 0000 0000 0001 &#x3D; 0001</span><br></pre></td></tr></table></figure>
<p>发生了哈希碰撞，而进行抑或运算，哈希值变为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 0000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line">b &#x3D; 0000 0000 0000 0001 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>
<p><code>(n - 1) &amp; hash</code>的结果是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1111 &amp; 0000 0000 0000 0000 0000 0000 0000 0001 &#x3D; 0001</span><br><span class="line">1111 &amp; 0000 0000 0000 0001 0000 0000 0000 0000 &#x3D; 0000</span><br></pre></td></tr></table></figure>
<p>成功避免了哈希碰撞。</p>
<h3 id="1-4-回到putVal"><a href="#1-4-回到putVal" class="headerlink" title="1.4 回到putVal"></a>1.4 回到putVal</h3><p>继续再看<code>putVal()</code>方法，根据<code>key</code>的哈希值计算出对应的桶数组下标，并判断桶数组的这一项是否为<code>null</code>，如果是，就调用<code>newNode</code>方法创建<code>Node</code>对象，并赋值给桶数组的这一项。而如果不是<code>null</code>，先定义一个<code>Node</code>类型的变量<code>e</code>，然后进一步做了判断：先检查第一个节点是否相同，相同就把这个节点的值赋给<code>e</code>；然后看节点是否为<code>TreeNode</code>类型，如果是，调用节点的<code>putTreeVal</code>方法，将返回值赋给<code>e</code>;如果不是，就遍历这个节点链表，查找是否有相同的<code>key</code>，找到了就赋值给<code>e</code>，如果找不到（下一个节点为<code>null</code>），就把要put的键值对添加到链表里。之后又做了一个判断，调用了<code>treeifyBin</code>方法。</p>
<p>看一下<code>putTreeVal</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tree version of putVal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line">            xp.next = x;</span><br><span class="line">            x.parent = x.prev = xp;</span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法不必逐行仔细看，重点关注三个<code>return</code>语句，前面两个都是在检索红黑树的过程中，查找/判断到了有和要put的<code>key</code>相同的节点，就直接返回了这个节点，第三个是在检索到最后也没找到的情况，是将键值对添加到了红黑树中，并返回了<code>null</code>。</p>
<p>可以这样理解，三个分支其实做了相同的事情，就是查找/判断要put的<code>key</code>是否已经存在，如果存在就将已存在的节点赋值给<code>e</code>做后续操作，如果不存在就将值添加到这个桶里，<code>e</code>的值保持为<code>null</code>。分支结束后，接下来判断了如果<code>e</code>不是<code>null</code>（也就是查找到了有相同的<code>key</code>的情况），就将要put的value值赋给<code>e</code>的<code>value</code>,并返回旧的<code>value</code>。</p>
<p>到这里，就完成了<code>put</code>操作。值得注意的是，在向链表增加了键值对之后，检查了链表的长度，并在其大于等于<code>TREEIFY_THRESHOLD - 1</code>（也就是7，因为前面对第一个节点单独进行了判断，这里对链表的遍历是从第二个节点开始的，所以链表的总长度应该是8）时，调用<code>treeifyBin(tab, hash)</code>将链表转换为了红黑树。此外，当<code>map</code>新增了键值对，数量超过阈值（<code>容量 * 负载因子</code>）时，对<code>map</code>的桶数组进行了<code>resize()</code>操作。<code>resize()</code>方法的注释是这样写的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment">     * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment">     * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment">     * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment">     * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 初始化或者把table的大小翻倍。如果是null，根据字段threshold中的初始容量值进行分配。</span></span><br><span class="line"><span class="comment">     * 否则，由于table的大小是2的幂，每个桶里的元素会保留在原来的位置，或者在新的表里以2的幂作为偏移量移动</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    	<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>resize()</code>的具体实现之后单独写一篇来分析，现在明确一点即可：<code>HashMap</code>在桶的数量超过（<code>容量 * 负载因子</code>）时就会进行<code>resize</code>操作，将桶的数量翻倍，元素要么保留在原来的位置，要么以2的幂作为偏移量移动到新的位置。</p>
<h2 id="2-get"><a href="#2-get" class="headerlink" title="2. get"></a>2. get</h2><h3 id="2-1-get方法的定义"><a href="#2-1-get方法的定义" class="headerlink" title="2.1 get方法的定义"></a>2.1 get方法的定义</h3><p><code>get</code>方法返回指定的键对应的值，或者当没有这个键时返回<code>null</code>。更正式的来说，如果<code>map</code>中包含像是<code>(key==null ? k==null :key.equals(k))</code> 这样的键为<code>k</code>,值为<code>v</code>的映射，那么这个方法返回<code>v</code>，否则返回<code>null</code>。（最多只会有一组这样的映射）。而返回<code>null</code>并不能说明<code>map</code>中不包含这个键的映射，因为有可能这个键映射的值就是<code>null</code>本身。（<del>废话</del>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></span><br><span class="line"><span class="comment"> * key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></span><br><span class="line"><span class="comment"> * it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> * indicate that the map contains no mapping for the key; it&#x27;s also</span></span><br><span class="line"><span class="comment"> * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment"> * distinguish these two cases.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-getNode方法——get操作的具体实现"><a href="#2-2-getNode方法——get操作的具体实现" class="headerlink" title="2.2 getNode方法——get操作的具体实现"></a>2.2 getNode方法——get操作的具体实现</h3><p>很明显，<code>get</code>的具体实现是在<code>getNode</code>方法里</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//判断table是否为null，大小是否为空，以及hash值对应的桶是否为null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first; <span class="comment">//检查第一个节点是否位要找的值，如果是就返回</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode) <span class="comment">//如果是红黑树</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); <span class="comment">//在树中检索，并返回结果</span></span><br><span class="line">            <span class="keyword">do</span> &#123; <span class="comment">//否则，也就node是链表的情况</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;<span class="comment">//查找到了，赋值，结束循环</span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有找到要查找的节点，返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先检查了桶数组是否为<code>null</code>、大小是否为0，然后用数组下标的计算方式<code>(n - 1) &amp; hash</code>获取到对应的桶，并判断是否为<code>null</code>。也就是判断<code>map</code>中是否包含要查找的键，如果不包含就直接返回<code>null</code>。如果包含的话就先检查第一个节点是否就是要查找的键，如果是就直接返回第一个节点，否则再按照链表和红黑树的不同方式遍历查找。找到就返回，找不到就最后返回<code>null</code>。</p>
<h3 id="2-3-为什么永远要检查第一个节点"><a href="#2-3-为什么永远要检查第一个节点" class="headerlink" title="2.3 为什么永远要检查第一个节点"></a>2.3 为什么永远要检查第一个节点</h3><p>注意这里源码中的注释：<code>always check first node</code>，永远要检查第一个节点。回想<code>HashMap</code>的实现内容，比如优化过的哈希值计算方法，扩容操作等都是在尽力避免哈希碰撞的发生，而无论节点的类型是链表（超过一个节点）还是红黑树，都是用来处理哈希碰撞的结构，是不希望出现的。理想的情况应该是尽可能不发生哈希碰撞，桶数组的每个桶里都只有一个<code>Node</code>，所以这里要<code>always check first node</code>。而在<code>putVal</code>和后面将要提到的<code>removeNode</code>方法的实现里，虽然没有像这里这样明确的注释，但实际上也是先对第一个节点做了检查，可见先检查第一个节点的重要性。</p>
<h2 id="3-remove"><a href="#3-remove" class="headerlink" title="3.remove"></a>3.remove</h2><h3 id="3-1-remove方法的定义"><a href="#3-1-remove方法的定义" class="headerlink" title="3.1 remove方法的定义"></a>3.1 remove方法的定义</h3><p><code>remove</code>方法：如果存在，就从<code>map</code>中移除指定键的映射。返回指定的键映射的值，如果没有映射关系，就返回<code>null</code>。和<code>get</code>方法一样，返回<code>null</code>并不能说明<code>map</code>中不包含这个键的映射，因为有可能这个键映射的值就是<code>null</code>本身。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the mapping for the specified key from this map if present.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  key key whose mapping is to be removed from the map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment"> *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-removeNode方法——remove操作的具体实现"><a href="#3-2-removeNode方法——remove操作的具体实现" class="headerlink" title="3.2 removeNode方法——remove操作的具体实现"></a>3.2 removeNode方法——remove操作的具体实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value, <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">//判断table是否为null，大小是否为空，以及hash值对应的桶是否为null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p; <span class="comment">//检查第一个节点是否为要找的值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">//如果是红黑树</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); <span class="comment">//在树中检索 </span></span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">//否则，也就node是链表的情况</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e; <span class="comment">//查找到了，赋值，结束循环</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否查到了要移除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123; <span class="comment">//remove调用时!matchValue恒为true</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode) <span class="comment">//如果是TreeNode，用removeTreeNode移除</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p) <span class="comment">//如果是第一个节点就是要移除的节点</span></span><br><span class="line">                tab[index] = node.next; <span class="comment">//把node的下一个节点赋值给桶数组</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next; <span class="comment">//如果是链表，把node的上一个节点链接到它的下一个节点，把node剔除出去</span></span><br><span class="line">            ++modCount;<span class="comment">//修改HashMap结构次数的计数器加1</span></span><br><span class="line">            --size; <span class="comment">//map中键值对的数量自减</span></span><br><span class="line">            afterNodeRemoval(node); <span class="comment">//提供给node节点移除后的回调方法</span></span><br><span class="line">            <span class="keyword">return</span> node; <span class="comment">//返回被移除的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有需要移除的节点，返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与<code>get</code>操作相同，先检查了桶数组是否为<code>null</code>、大小是否为0，然后用数组下标的计算方式<code>(n - 1) &amp; hash</code>获取到对应的桶，并判断是否为<code>null</code>。也就是判断<code>map</code>中是否包含要查找的键，如果不包含就直接返回<code>null</code>。如果包含，接下来定义了<code>Node</code>类型的变量<code>node</code>，然后按照<code>getNode</code>方法中的查找方式，先检查第一个节点是否为想移除的，不是的话再按照链表和红黑树的不同方式遍历查找，找到就赋值给<code>node</code>，否则<code>node</code>就保持为<code>null</code>。查找完成后，先检查<code>node</code>是否为<code>null</code>，如果是，就直接返回<code>null</code>。如果不是，就按照<code>node</code>的类型分别移除节点：如果是<code>TreeNode</code>，调用<code>removeTreeNode</code>方法移除节点；如果是第一个节点，就把桶数组的这一项改为这个节点的下一个节点；如果是链表，就把这个节点的上个节点链接到这个节点的下个节点，把它从链表中移除。完成移除后，增加修改<code>HashMap</code>结构的计数器，自减键值对的数量，最后返回这个节点本身。</p>

  </div>
</article>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/posts/">Writing</a></li>
         
          <li><a target="_blank" rel="noopener" href="http://github.com/ZhangAndong12138">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-put"><span class="toc-number">1.</span> <span class="toc-text">1. put</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-put%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 put方法的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-putVal%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94put%E6%93%8D%E4%BD%9C%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 putVal方法——put操作的具体实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-hash%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E9%81%BF%E5%85%8D%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 hash方法——避免哈希碰撞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%9B%9E%E5%88%B0putVal"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 回到putVal</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-get"><span class="toc-number">2.</span> <span class="toc-text">2. get</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-get%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 get方法的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-getNode%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94get%E6%93%8D%E4%BD%9C%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 getNode方法——get操作的具体实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B0%B8%E8%BF%9C%E8%A6%81%E6%A3%80%E6%9F%A5%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 为什么永远要检查第一个节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-remove"><span class="toc-number">3.</span> <span class="toc-text">3.remove</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-remove%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 remove方法的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-removeNode%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94remove%E6%93%8D%E4%BD%9C%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 removeNode方法——remove操作的具体实现</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2022/07/20/HashMap%EF%BC%882%EF%BC%89-%20put%E3%80%81get%E5%92%8Cremove%E6%96%B9%E6%B3%95/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2022/07/20/HashMap%EF%BC%882%EF%BC%89-%20put%E3%80%81get%E5%92%8Cremove%E6%96%B9%E6%B3%95/&text=HashMap（2）- put、get和remove方法"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2022/07/20/HashMap%EF%BC%882%EF%BC%89-%20put%E3%80%81get%E5%92%8Cremove%E6%96%B9%E6%B3%95/&title=HashMap（2）- put、get和remove方法"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2022/07/20/HashMap%EF%BC%882%EF%BC%89-%20put%E3%80%81get%E5%92%8Cremove%E6%96%B9%E6%B3%95/&is_video=false&description=HashMap（2）- put、get和remove方法"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=HashMap（2）- put、get和remove方法&body=Check out this article: http://example.com/2022/07/20/HashMap%EF%BC%882%EF%BC%89-%20put%E3%80%81get%E5%92%8Cremove%E6%96%B9%E6%B3%95/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2022/07/20/HashMap%EF%BC%882%EF%BC%89-%20put%E3%80%81get%E5%92%8Cremove%E6%96%B9%E6%B3%95/&title=HashMap（2）- put、get和remove方法"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2022/07/20/HashMap%EF%BC%882%EF%BC%89-%20put%E3%80%81get%E5%92%8Cremove%E6%96%B9%E6%B3%95/&title=HashMap（2）- put、get和remove方法"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2022/07/20/HashMap%EF%BC%882%EF%BC%89-%20put%E3%80%81get%E5%92%8Cremove%E6%96%B9%E6%B3%95/&title=HashMap（2）- put、get和remove方法"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2022/07/20/HashMap%EF%BC%882%EF%BC%89-%20put%E3%80%81get%E5%92%8Cremove%E6%96%B9%E6%B3%95/&title=HashMap（2）- put、get和remove方法"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2022/07/20/HashMap%EF%BC%882%EF%BC%89-%20put%E3%80%81get%E5%92%8Cremove%E6%96%B9%E6%B3%95/&name=HashMap（2）- put、get和remove方法&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2022 zad
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/posts/">Writing</a></li>
         
          <li><a target="_blank" rel="noopener" href="http://github.com/ZhangAndong12138">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<link rel="stylesheet" href="/lib/meslo-LG/styles.css">


<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">


<!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>


<script src="/js/main.js"></script>



    <!-- Google Analytics -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-37473492-6', 'auto');
        ga('send', 'pageview');
    </script>



